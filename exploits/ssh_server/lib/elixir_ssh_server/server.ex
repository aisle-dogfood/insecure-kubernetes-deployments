defmodule ElixirSshServer.Server do
  use GenServer
  require Logger

  def start_link(_) do
    GenServer.start_link(__MODULE__, [], name: __MODULE__)
  end

  def init(_) do
    Logger.info("Starting SSH server...")
    
    system_dir = '/root/ssh_keys' |> to_charlist
    
    options = [
      system_dir: system_dir,
      user_dir: system_dir,
      auth_methods: 'password',
      pwdfun: &password_callback/2,
      id_string: 'SSH-2.0-VulnerableServer',
      ssh_cli: {__MODULE__, []},
      subsystems: []
    ]

    case :ssh.daemon(22, options) do
      {:ok, pid} ->
        Logger.info("SSH server started successfully on port 22")
        {:ok, %{ssh_pid: pid}}
      {:error, reason} ->
        Logger.error("Failed to start SSH server: #{inspect(reason)}")
        {:stop, reason}
    end
  end

  def password_callback(username, password) do
    Logger.info("Login attempt: #{inspect(username)}/#{inspect(password)}")
    
    case {username, password} do
      {'dummy', 'password123'} -> true
      _ -> false
    end
  end

  # SSH CLI callbacks
  def init([]) do
    {:ok, []}
  end

  def handle_ssh_msg({:ssh_cm, _conn_ref, {:data, _channel_id, 0, data}}, state) do
    Logger.info("Received data: #{inspect(data)}")
    {:ok, state}
  end

  def handle_ssh_msg({:ssh_cm, _conn_ref, {:eof, _channel_id}}, state) do
    {:ok, state}
  end

  def handle_ssh_msg({:ssh_cm, _conn_ref, {:shell, _channel_id}}, state) do
    {:ok, state}
  end

  def handle_ssh_msg({:ssh_cm, _conn_ref, {:exec, _channel_id, _command}}, state) do
    {:ok, state}
  end

  def handle_ssh_msg(_msg, state) do
    {:ok, state}
  end

  def terminate(_reason, _state) do
    :ok
  end
end 